function names_units = mrjson_show(varargin)
% function names_units = mrjson_show(fnmat,names_units)
% function names_units = mrjson_show(js,names_units,outfile)
%
% *************************************************************************
% mexec interface for RVDAS data acquisition
% First drafts of scripts for start jc211 28 jan 2021, alongside in Stanley
% 
% Evolution on that cruise by bak, ylf, pa
% *************************************************************************
%
% Show the sentences in the rvdas json file (via .mat or structure via
% jsondecode), and store variable names and units.
%
% Examples
%
%   names_units = mrshow_json('posmv_gyro-jc')  % start a new names_units structure
%   names_units = mrshow_json('posmv_pos-jc',names_units) % add to the existing structure
%   names_units = mrshow_json(js, names_units) %pass structure as in
%       mrshow_json_all.m
%
% Input:
%
% fnmat is a .mat file that has been converted from .json to .mat by
%   jsondecode in matlab. This was introduced to matlab around 2016, so was
%   not available on koaeula on JR211. The conversion was done on BAK's mac.
% OR
% js is a structure generated by jsondecode
%
% names_units is an optional argument. If present, the output names_units
%   is added to the input.
% 
% Output:
% 
% to outfile if specified, else to screen: The content of the js structure
% loaded from the sentences in a json file
%
% names_units : is a structure. Each field describes a table in rvdas.
%   The function writes, for example
%     names_units.posmv_pos_gpgga
%     names_units.posmv_pos_gpggk
%   If the next call has names_units as an input argument, the next set of
%        tables from the next json/mat file will be added.
%     names_units.posmv_gyro_prdid
%     names_units.posmv_gyro_pashr

% names_units has fieldnames that are rvdas table names
%   Each table name has fieldnames that are the variable names for that table
%   The contents of each variable name is a string equal to the variable units.

if isstruct(varargin{1})
    js = varargin{1};
elseif ischar(varargin{1}) && exist(varargin{1},'file')
    load(varargin{1})
    [~,fname,~] = fileparts(varargin{1});
    js.filename = fname; %fnroot
end
if nargin > 1
    d = varargin{2};
end
if nargin > 2
    outfile = varargin{3};
    fid = fopen(outfile,'a');
else
    fid = 1;
end

% % n_sentences = js.sentencesNo; % The seapath_pos json file 
% has sentencesNo set to 9, but it actually has 10 sentences.
n_sentences = length(js.sentences);
fprintf(fid,'\n\n%s%s %2d%s\n','%',js.filename,n_sentences,'  sentences');

for ks = 1:n_sentences
    id = js.id; id = lower(id);
    s = js.sentences(ks);
    jsonname = s.name;
    talkId = s.talkId;
    messageId = s.messageId;
    noflds = length(s.field); %s.fieldNo;
    msg = lower([talkId messageId]);
    sqlname = [id '_' msg];
    fprintf(fid,'\n%s%s%s%s\n','%','"',jsonname,'"'); % make this output a comment for cut and paste
    str = ['rtables.' sqlname ' = {  % from ' js.filename '.json'];
    fprintf(fid,'%s\n',str);
    fprintf(fid,'%s %2d %s\n',['''' sqlname ''''],noflds,' % fields');
    for kf = 1:noflds
        sf = s.field(kf);
        if iscell(sf)
            f = s.field{kf};
        else
            f = s.field(kf);
        end
        fname = f.fieldNumber; %[f.fieldNumber '_' f.name];
        if isfield(f,'units'); funit = f.units; else; funit = f.unit; end
        fprintf(fid,'%30s %30s\n',['''' fname ''''],['''' funit '''']);
        try
            d.(sqlname).(fname) = funit; % will fail if sqlname or fname are invalid. Some gravity meter json files define names that are invalid matab names, eg with spaces and starting with a number
        catch
            sqlname = matlab.lang.makeValidName(sqlname);
            fname = matlab.lang.makeValidName(fname); 
            d.(sqlname).(fname) = funit;
        end
    end
    fprintf(fid,'%s\n','};');
    
end
if fid~=1; fclose(fid); end

names_units = d;
return