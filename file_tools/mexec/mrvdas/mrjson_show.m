function names_units = mrjson_show(varargin)
% function names_units = mrjson_show(fnmat,names_units)
% function names_units = mrjson_show(js,names_units,outfile)
%
% *************************************************************************
% mexec interface for RVDAS data acquisition
% First drafts of scripts for start jc211 28 jan 2021, alongside in Stanley
% 
% Evolution on that cruise by bak, ylf, pa
% *************************************************************************
%
% Show the sentences in the rvdas json file (via .mat or structure via
% jsondecode), and store variable names and units.
%
% Examples
%
%   names_units = mrjson_show('posmv_gyro-jc')  % start a new names_units structure
%   names_units = mrjson_show('posmv_pos-jc',names_units) % add to the existing structure
%   names_units = mrjson_show(js, names_units) %pass structure as in
%       mrshow_json_all.m
%
% Input:
%
% fnmat is a .mat file that has been converted from .json to .mat by
%   jsondecode in matlab. This was introduced to matlab around 2016, so was
%   not available on koaeula on JR211. The conversion was done on BAK's mac.
% OR
% js is a structure generated by jsondecode
%
% names_units is an optional argument. If present, the output names_units
%   is added to the input.
% 
% Output:
% 
% to outfile if specified, else to screen: The relevant content of the js
%   structure loaded from the sentences in a json file;
%   variables set (by cruise options) to be skipped (those matching the
%   var_skip, pat_skip, or sentence_var_skip lists) will be omitted from
%   names_units and commented out in outfile
%
% names_units : is a structure. Each field describes a table in rvdas.
%   The function writes, for example
%     names_units.posmv_pos_gpgga
%     names_units.posmv_pos_gpggk
%   If the next call has names_units as an input argument, the next set of
%        tables from the next json/mat file will be added.
%     names_units.posmv_gyro_prdid
%     names_units.posmv_gyro_pashr

% names_units has fieldnames that are rvdas table names
%   Each table name has fieldnames that are the variable names for that
%   table; each variable name has two fields, units and long_name, whose
%   contents are the variable units and long name (js.sentences.name)

if isstruct(varargin{1})
    js = varargin{1};
elseif ischar(varargin{1}) && exist(varargin{1},'file')
    load(varargin{1})
    [~,fname,~] = fileparts(varargin{1});
    js.filename = fname; %fnroot
end
for no = 2:nargin
    if isstruct(varargin{no})
        d = varargin{no};
    elseif ischar(varargin{no})
        outfile = varargin{no};
    end
end

if exist('outfile','var')
    fid = fopen(outfile,'a');
else
    fid = 1;
end

scriptname = 'mrvdas_ingest'; oopt = 'rvdas_skip'; get_cropt

n_sentences = length(js.sentences);
id = js.id; id = lower(id);
fprintf(fid,'\n\n%s%s %2d%s\n','%',js.filename,n_sentences,'  sentences');

specchar = {' ', ',', '''', ';'};

scriptname = 'mrvdas_ingest'; oopt = 'rvdas_cruise_table_pre'; get_cropt

for ks = 1:n_sentences

    s = js.sentences(ks);
    jsonname = s.name;
    talkId = s.talkId;
    messageId = s.messageId;
    noflds = length(s.field); %s.fieldNo;
    msg = lower([talkId messageId]);
    sqlname = [sqlpre id '_' msg];
    %skip this sentence?
    if sum(strcmpi(msg,msg_skip)) || sum(strcmpi(sqlname,sentence_skip))
        continue
    end

    str = ['rtables.' sqlname ' = {  % from ' js.filename '.json'];
    fprintf(fid,'\n%s%s%s%s\n','%','"',jsonname,'"'); % make this output a comment for cut and paste
    fprintf(fid,'%s\n',str);
    fprintf(fid,'%s %2d %s %s\n',['''' sqlname ''''],noflds,'[]',' % fields');

    for kf = 1:noflds
        sf = s.field(kf);
        if iscell(sf)
            f = s.field{kf};
        else
            f = s.field(kf);
        end
        fname = f.fieldNumber;
        longname = replace(f.name, specchar, '_');
        if isfield(f,'units'); funit = f.units; else; funit = f.unit; end
        
        skipit = false;
        if ~isempty(var_skip)
            skipit = skipit || sum(strcmpi(fname,var_skip));
        end
        if ~isempty(sentence_var_skip)
            skipit = skipit || sum(strcmpi([sqlname '_' fname],sentence_var_skip));
        end
        if ~isempty(pat_skip)
            skipit = skipit || sum(contains(fname,pat_skip,'IgnoreCase',true));
        end
        if skipit
            fprintf(fid,'%s %28s %30s %80s\n','%',['''' fname ''''],['''' funit ''''],['''' longname '''']);
        else
            fprintf(fid,'%30s %30s %80s\n',['''' fname ''''],['''' funit ''''],['''' longname '''']);
            try
                d.(sqlname).(fname).units = funit; % will fail if sqlname or fname are invalid. Some gravity meter json files define names that are invalid matab names, eg with spaces and starting with a number
                d.(sqlname).(fname).long_name = longname;
            catch
                sqlname = matlab.lang.makeValidName(sqlname);
                fname = matlab.lang.makeValidName(fname);
                d.(sqlname).(fname).unit = funit;
                d.(sqlname).(fname).long_name = longname;
            end
        end
    end
    fprintf(fid,'%s\n','};');
    
end
if fid~=1; fclose(fid); end

names_units = d;
return